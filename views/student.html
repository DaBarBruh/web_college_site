<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Neon Gyro</title>
  <style>
    html,body{
      height:100%;
      margin:0;
      overflow:hidden;
      background:
        radial-gradient(1200px 900px at 70% 20%, #20106b 0%, rgba(32,16,107,0) 60%),
        radial-gradient(900px 700px at 20% 75%, #0a5c8a 0%, rgba(10,92,138,0) 55%),
        linear-gradient(180deg,#050512,#0b0830);
    }
    canvas{display:block;width:100%;height:100%}
  </style>
</head>
<body>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

/* Renderer */
const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

/* Scene & Camera */
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x060616, 0.035);

const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 200);
camera.position.set(0,0,10);

/* Lights */
scene.add(new THREE.AmbientLight(0xffffff,0.25));
const l1 = new THREE.PointLight(0x7cfffd,2.2,60);
l1.position.set(8,6,10); scene.add(l1);
const l2 = new THREE.PointLight(0xff4dff,1.8,60);
l2.position.set(-8,-2,14); scene.add(l2);

/* Particles */
const COUNT = 4200;
const pos = new Float32Array(COUNT*3);
const col = new Float32Array(COUNT*3);
const size = new Float32Array(COUNT);

const neon = [
  new THREE.Color("#7cfffd"),
  new THREE.Color("#ff4dff"),
  new THREE.Color("#7c5cff")
];

for(let i=0;i<COUNT;i++){
  const i3=i*3;
  const z = Math.random()*-70;
  const a = Math.random()*Math.PI*2;
  const r = Math.pow(Math.random(),0.55)*16;
  pos[i3]=Math.cos(a)*r;
  pos[i3+1]=Math.sin(a)*r*0.7;
  pos[i3+2]=z;

  const c = neon[Math.floor(Math.random()*3)];
  col[i3]=c.r; col[i3+1]=c.g; col[i3+2]=c.b;
  size[i]=0.6+Math.random()*3.4;
}

const g = new THREE.BufferGeometry();
g.setAttribute("position",new THREE.BufferAttribute(pos,3));
g.setAttribute("color",new THREE.BufferAttribute(col,3));
g.setAttribute("aSize",new THREE.BufferAttribute(size,1));

const m = new THREE.ShaderMaterial({
  transparent:true,
  depthWrite:false,
  blending:THREE.AdditiveBlending,
  vertexColors:true,
  uniforms:{
    uTime:{value:0},
    uPR:{value:Math.min(devicePixelRatio,2)}
  },
  vertexShader:`
    uniform float uTime,uPR;
    attribute float aSize;
    varying vec3 vColor;
    void main(){
      vColor=color;
      vec3 p=position;
      p.x+=sin(p.z*0.18+uTime)*0.12;
      p.y+=cos(p.z*0.15+uTime)*0.08;
      vec4 mv=modelViewMatrix*vec4(p,1.0);
      gl_Position=projectionMatrix*mv;
      gl_PointSize=clamp(aSize*(70.0/-mv.z)*uPR,1.5,18.0);
    }
  `,
  fragmentShader:`
    varying vec3 vColor;
    void main(){
      float d=length(gl_PointCoord-0.5);
      float a=smoothstep(0.5,0.0,d);
      gl_FragColor=vec4(vColor,a);
    }
  `
});

const points=new THREE.Points(g,m);
scene.add(points);

/* Rings */
function ring(r,t,c,z){
  const mesh=new THREE.Mesh(
    new THREE.TorusGeometry(r,t,16,120),
    new THREE.MeshStandardMaterial({
      color:c,emissive:c,emissiveIntensity:1,
      metalness:0.6,roughness:0.2
    })
  );
  mesh.position.z=z;
  scene.add(mesh);
  return mesh;
}

const r1=ring(3,0.12,0x7cfffd,-6);
const r2=ring(4.1,0.08,0xff4dff,-14);
const r3=ring(5.3,0.06,0x7c5cff,-24);

/* Motion */
let tx=0,ty=0,sx=0,sy=0;
window.addEventListener("pointermove",e=>{
  tx=(e.clientX/innerWidth-0.5)*2;
  ty=(e.clientY/innerHeight-0.5)*-2;
});

window.addEventListener("deviceorientation",e=>{
  tx=THREE.MathUtils.clamp((e.gamma||0)/35,-1,1);
  ty=THREE.MathUtils.clamp((e.beta||0)/45,-1,1);
},true);

/* Animate */
const clock=new THREE.Clock();
function animate(){
  requestAnimationFrame(animate);
  const t=clock.getElapsedTime();
  m.uniforms.uTime.value=t;

  sx+=(tx-sx)*0.08;
  sy+=(ty-sy)*0.08;

  camera.position.x=Math.sin(t*0.35)*0.55+sx*1.2;
  camera.position.y=Math.cos(t*0.28)*0.35+sy*0.9;
  camera.lookAt(sx*0.4,sy*0.3,-18);

  points.position.z=(t*7.5)%70;
  r1.rotation.z+=0.002;
  r2.rotation.x+=0.002;
  r3.rotation.y+=0.002;

  renderer.render(scene,camera);
}
animate();

addEventListener("resize",()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
